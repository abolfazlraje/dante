# $Id: socks.conf,v 1.13 1999/03/11 16:40:43 michaels Exp $
#
# A sample socks.conf

# The configfile is divided into two parts; first misc. settings, 
# then the routes.  Objects in '[]' are optional.
#
#
# order is:
#	[logoutput]
#       localdomain
#       [debug]
#       
#       route
#               [from] [to] via
#               [command]
#               [extension]
#               [protocol]
#               [proxyprotocol]


#logoutput: stdout  # users don't want to be bothered with that.
#localdomain: x.y    # gives your local domain.
#debug: 1           # no debugging either.

# have a route making all connections to loopback address's be direct.
#route {
#	from: 0.0.0.0/0   to: 127.0.0.0/8  via: direct
#}

# Our net is the 10.0.0.0/8 net, let clients going to local address go
# direct, not via server.
#route {
#	from: 0.0.0.0/0   to: 10.0.0.0/8   via: direct
#}

# if you don't route all local connections via direct, you should
# at least route nameserver connections via direct connections if you can,
# since that makes for better performance.  Assuming your nameserver runs
# on address 10.1.1.1, you can do it like this:
#route {
#	from: 0.0.0.0/0 to: 10.1.1.1/32 port = domain via: direct
#}

# 
# for poor souls trapped behind a msproxy server.
#
#route {
#	from: 0.0.0.0/0   to: 0.0.0.0/0   via: 10.1.1.1 port = 1745
#	protocol: tcp 			 # server supports tcp 
#	proxyprotocol: msproxy_v2        # server runs msproxy_v2
#}

# clients going anywhere else go via server listening at 
# ipaddress 10.1.1.1, port 1080.   Note that unless you have
# specified a direct connection for dns, or the socksserver is resolvable
# without tcp/udp, you can't give a hostname for the socksserver, you
# must give a ip address.  (the reasons for that are logical enough,
# you would create a loop.)
#route {
#	from: 0.0.0.0/0   to: 0.0.0.0/0   via: 10.1.1.1 port = 1080
#	protocol: tcp udp                # server supports tcp and udp.
#	proxyprotocol: socks_v4 socks_v5  # server supports socks v4 and v5.
#	method: none username 	         # we are willing to authenticate via
#					 # either method "none" or username.
#}

# this is identical to the above, but it matches hostnames instead.
# This is if you have clients that are unable to resolve hostnames.
#route {
#	from: 0.0.0.0/0   to: .   via: 10.1.1.1 port = 1080
#	protocol: tcp udp                # server supports tcp and udp.
#	proxyprotocol: socks_v4 socks_v5  # server supports socks v4 and v5.
#	method: none username 	         # we are willing to authenticate via
#					 # either method "none" or username.
#}
