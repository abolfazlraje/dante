# $Id: sockd.conf,v 1.10 1999/01/12 12:11:33 michaels Exp $
#
# A sample sockd.conf
#
#
# The configfile is divided into two parts; first serversettings, 
# then the rules.  Objects in '[]' are optional.
#
# The order of the individual parts that can be set is:
#   Serversettings:
#               [logoutput]
#               [internal]
#               external
#               localdomain
#               method
#               users
#               [compatability]
#               [extension]
#               [connecttimeout]
#               [iotimeout]
#               [debug]
#
#  Rules:
#       client block/pass
#		[libwrap]  # not recommended, if you can, set it at level above.
#		[log]
#
#       block/pass
#		[protocol]
#		[from to]
#		[authmethod]
#		[command]
#		[libwrap]
#		[log]
#		[proxyprotocol]

# the server will log both via syslog, to stdout and to /var/log/lotsoflogs
logoutput: syslog stdout /var/log/lotsoflogs

# The server will bind to the address 10.1.1.1, port 1080 and will only
# accept connections going to that address.
internal: 10.1.1.1 port = 1080

# all outgoing connections from the server will use the ipaddress 
# 195.168.1.1
external: 192.168.1.1 

# we need to let the server know what our local domainname is
localdomain: x.y

# list over acceptable methods in order of preference
method: username none



# 
# An important section, pay attention.
#

# when doing something that can require privilege, it will use the 
# userid "sockd".  
user.privileged: sockd

# when running as usual, it will use the unprivileged userid of "sockd".
user.notprivileged: sockd

# If you compiled with libwrap support, what userid should it use
# when executing your libwrap commands?  "libwrap".
user.libwrap: libwrap

# some options to help clients with compatability:

# when a client connection comes in, the socksserver will try to use
# the same port as the client is using, when it goes out
# (external: ipaddress) on the clients behalf. 
# If this option is set, Dante will try to do it for reserved ports aswell,
# this will usually require user.privileged to be set to "root".
#compatibility: sameport

# If you are using the bind extension and have trouble running servers
# via the server, you might try setting this.  The consequences of it
# are unknown. 
#compatibility: reuseaddr


# misc options.

# how many seconds can pass from when a client connects til it has
# sent us it's request?  Adjust according to your network performance
# and methods supported.
connecttimeout: 30   # on a lan, this should be enough if method is "none".

# how many seconds can the client and it's peer idle without sending
# any data before we dump it?
iotimeout: 86400 # we give it a day.  0 is "forever"



# The actual rules.  There are two kinds and they work at different levels.
#
# The rules prefixed with "client" are checked first and say who is allowed
# and who is not allowed to speak/connect to the server.  I.e the
# ip range containing possibly valid clients.
# It is especially important that these only use ipaddress', not hostnames,
# both for security reasons and performance.
#
# The rules that do not have a "client" prefix are checked later, when the
# client has sent it's request.
#
# The "to:" in the "client" context gives the address the connection 
# is accepted on, i.e the address the socksserver is listening on, or
# just "0.0.0.0/0" for any address the server is listening on.
#
# The "to:" in the non-"client" context gives the destination of the clients
# socksrequest. 

# the "client" rules.  All our clients come from the net 10.0.0.0/8.
client pass {
 	from: 10.0.0.0/8 to: 0.0.0.0
}

# drop everyone else as soon as we can and log the connect, they are not
# on our net and have no business connecting to us.
client block {
	from: 0.0.0.0/0 to: 0.0.0.0/0
	log: connect
}


# the rules controlling what clients are allowed what requests

# you probably don't want people connecting to loopback address's,
# who knows what could happen then.
block {
	from: 0.0.0.0/0 to: 127.0.0.0/8
	log: connect
}

# the people at the 172.16.0.0/12 are bad, no one should talk to them.
# log the connect request and also provide an example on how to
# interact with libwrap.
block {
	from: 0.0.0.0/0 to: 172.16.0.0/12 port = any
	libwrap: rfc931
	log: connect
}

# unless you need it, you could block any bind requests.
block {
	from: 0.0.0.0/0 to: 0.0.0.0/0
	command: bind
	log: connect	# perhaps someone will want to bind?
}

# everyone from our internal network, 10.0.0.0/8 is allowed to use 
# tcp and udp to anywhere they want. 
pass {
	protocol: tcp udp
	from: 10.0.0.0/8 to: 0.0.0.0/0
}

# last line, block everyone else.  This is the default but if you provide
# one  yourself you can specify your own logging/actions
block {
	log: connect 
}
